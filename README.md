# [JAVA] 코딩 테스트 대비 알고리즘 문제 풀이

### 복습할 문제
- BFS
  - 4179
  - 2206(벽부수기)
### BFS의 시간복잡도, 공간복잡도 확인
- BFS는 1번씩만 방문하므로 예를들어 rxcxh의 배열에 대해 BFS를 수행하면 시간복잡도, 공간복잡도 모두 RxCxH입니다 (공간복잡도 에서는 저만큼을 저장할 배열이 필요하기때문)
- BFS에서는 1번씩만 방문하도록 큐에 잘 집어넣는것이 중요(중복된 값이 여러번 들어가면 시간초과와 같은 다양한 문제가 생김)

### 2206 벽부수기에서 visited하나만 있으면 안되는이유
- 예를 들어 벽을 일찍 부수고 이전에 방문하지 않은 셀을 통과하면 더 빨리 도착하는 경로가 있을 수 있고,
  일부 셀을 먼저 방문한 다음 벽을 부수면 더 빨리 도착하는 경로가 있을 수 있다.
- 하나의 visit[][]만 사용한 경우 상태를 덮어쓰고 하나의 잠재적 경로를 잃을 수 있다.

### 입력 100ms 빠르게 하기
- 2206제출한 답변 보면 활용한 코드를 볼 수 있습니다
- 그런데 보통 입력은 프로그래머스같은 경우도 parameter로 주는 경우가 많아서.. 필요할때 보도록 합시다..
```java
static int read() throws Exception {
    int c, n = System.in.read() & 15; // 1. 입력 스트림에서 문자를 읽습니다. "& 15" 연산은 숫자의 ASCII 값을 실제 수치값으로 변환하기 위해 수행됩니다.

    while ((c = System.in.read()) > 32) { // 2. 입력 스트림에서 다음 문자를 읽습니다. 이 문자가 공백(' '), 즉 ASCII 값이 32보다 큰 경우에만 반복문을 계속 실행합니다.
        n = (n << 3) + (n << 1) + (c & 15); // 3. 이전에 읽은 숫자를 10배 하고, 현재 읽은 숫자를 더함으로써 새로운 숫자를 만듭니다.
    }

    if(c == 13) { // 4. 만약 현재 읽은 문자가 '\r' (ASCII 값이 13인 캐릭터)인 경우,
        System.in.read(); // 5. '\n' 문자를 읽어서 버립니다. (윈도우 시스템에서 줄바꿈을 '\r\n'으로 표현하기 때문입니다.)
    }

    return n; // 6. 만들어진 숫자를 반환합니다.
}
```
